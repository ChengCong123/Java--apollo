[TOC]

# 模型
>&nbsp;&nbsp;&nbsp;&nbsp;CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下执行函数：CAS(V,E,N)其包含3个参数: V表示要更新的变量,E表示预期值,N表示新值。


>&nbsp;&nbsp;&nbsp;&nbsp; 如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下

![在这里插入图片描述](https://github.com/wuxiaobo000111/pictures/blob/master/2019-04-03/3.png?raw=true)


>&nbsp;&nbsp;&nbsp;&nbsp; 由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。

# 如何实现

>&nbsp;&nbsp;&nbsp;&nbsp;java中由UnSafe类实现,关于UnSafe的介绍放在了同级目录下。

