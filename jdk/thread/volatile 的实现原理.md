# 概述

>&nbsp;&nbsp;&nbsp;&nbsp; volatile ，则是轻量级的 synchronized ，它在多线程开发中保证了共享变量的“可见性”。如果一个变量使用 volatile ，则它比使用 synchronized 的成本更加低，因为它不会引起线程上下文的切换和调度。

# Java内存模型

>&nbsp;&nbsp;&nbsp;&nbsp;计算机在运行程序时，每条指令都是在 CPU 中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有 CPU 中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了 CPU 高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。
&nbsp;&nbsp;&nbsp;&nbsp;有了 CPU 高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到 CPU 高速缓存中，在进行运算时 CPU 不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后，才会将数据刷新到主存中。举一个简单的例子：i=i+1;
&nbsp;&nbsp;&nbsp;&nbsp;当线程运行这段代码时，首先会从主存中读取 i 的值( 假设此时 i = 1 )，然后复制一份到 CPU 高速缓存中，然后 CPU 执行 + 1 的操作（此时 i = 2），然后将数据 i = 2 写入到告诉缓存中，最后刷新到主存中。实这样做在单线程中是没有问题的，有问题的是在多线程中。如下：假如有两个线程 A、B 都执行这个操作（ i++ ），按照我们正常的逻辑思维主存中的i值应该=3 。但事实是这样么？分析如下：两个线程从主存中读取 i 的值( 假设此时 i = 1 )，到各自的高速缓存中，然后线程 A 执行 +1 操作并将结果写入高速缓存中，最后写入主存中，此时主存 i = 2 。线程B做同样的操作，主存中的 i 仍然 =2 。所以最终结果为 2 并不是 3 。这种现象就是缓存一致性问题。

## 如何解决缓存一致性问题

```text
    通过在总线加 LOCK# 锁的方式
        第一种方案， 存在一个问题，它是采用一种独占的方式来实现的，即总线加 LOCK# 锁的话，只能有一个 CPU 
        能够运行，其他 CPU 都得阻塞，效率较为低下。
    通过缓存一致性协议
        第二种方案，缓存一致性协议（MESI 协议），它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如
        下：当某个 CPU 在写数据时，如果发现操作的变量是共享变量，则会通知其他 CPU 告知该变量的缓存行是无
        效的，因此其他 CPU 在读取该变量时，发现其无效会重新从主存中加载数据。
```

#  volatile 原理

>&nbsp;&nbsp;&nbsp;&nbsp;volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层，volatile 是采用“内存屏障”来实现的。上面那段话，有两层语义：1.保证可见性、不保证原子性。2.禁止指令重排序。

## 什么是指令重排序

>&nbsp;&nbsp;&nbsp;&nbsp;在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：1。编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。2。处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
&nbsp;&nbsp;&nbsp;&nbsp;指令重排序对单线程没有什么影响，他不会影响程序的运行结果，但是会影响多线程的正确性。既然指令重排序会影响到多线程执行的正确性，那么我们就需要禁止重排序。

## JVM是如何禁止重排序的呢

```text
    1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作，happens-before 于书写在后面的操作。

    2.锁定规则：一个 unLock 操作，happens-before 于后面对同一个锁的 lock 操作。

    3.volatile 变量规则：对一个变量的写操作，happens-before 于后面对这个变量的读操作。

    4.传递规则：如果操作 A happens-before 操作 B，而操作 B happens-before 操作C，则可以得出，操作 A 
    happens-before 操作C

    5.线程启动规则：Thread 对象的 start 方法，happens-before 此线程的每个一个动作。
    
    6.线程中断规则：对线程 interrupt 方法的调用，happens-before 被中断线程的代码检测到中断事件的发生。

    7.线程终结规则：线程中所有的操作，都 happens-before 线程的终止检测，我们可以通过Thread.join() 方法结束、
    Thread.isAlive() 的返回值手段，检测到线程已经终止执行。

    8.对象终结规则：一个对象的初始化完成，happens-before 它的 finalize() 方法的开始
```

>&nbsp;&nbsp;&nbsp;&nbsp;我们着重看第三点 Volatile规则：对 volatile变量的写操作，happen-before 后续的读操作。为了实现 volatile 内存语义，JMM会重排序，其规则如下：


![在这里插入图片描述](https://github.com/wuxiaobo000111/pictures/blob/master/2019-05-10/20.png?raw=true)


>&nbsp;&nbsp;&nbsp;&nbsp;当第二个操作是 volatile 写操作时，不管第一个操作是什么，都不能重排序。这个规则，确保 volatile 写操作之前的操作，都不会被编译器重排序到 volatile 写操作之后。
&nbsp;&nbsp;&nbsp;&nbsp;观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令，其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile 的底层就是通过内存屏障来实现的。下图是完成上述规则所需要的内存屏障：

![在这里插入图片描述](https://github.com/wuxiaobo000111/pictures/blob/master/2019-05-10/21.png?raw=true)