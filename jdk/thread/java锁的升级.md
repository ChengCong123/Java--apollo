![在这里插入图片描述](https://github.com/wuxiaobo000111/pictures/blob/master/2019-04-01/1.png?raw=true)



>我们都知道在JDK5中出现了Concurrent包，里面的lock锁性能比它好，使用起来也很灵活。这就把synchronized比下去了，在当时synchronized不管什么情况就是加锁、解锁，每次都要切换到内核态来做这些操作，导致CPU浪费了大量时间在线程的调度上。synchronized觉得不这不公平，我性能又差，而且还不灵活，那以后谁还用我！java一看，觉得不能偏心，就在jdk6的时候给synchronized进行了一个大优化，也就是上面提到的：引入偏向锁和轻量级锁。

### 偏向锁

>偏向锁实际上是一种锁优化的，其目的是为了减少数据在无竞争情况下的性能消耗。其核心思想就是锁会偏向第一个获取它的线程，在接下来的执行过程中该锁没有其他的线程获取，则持有偏向锁的线程永远不需要再进行同步。


### 偏向锁的获取

>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里储存锁偏向的线程ID。
以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要检查当前Mark 
Word中储存的线程是否指向当前线程，如果成功，表示已经获得对象锁；如果检测失败，
则需要再测试一下Mark Word中偏向锁的标志是否已经被置为1（表示当前锁是偏向锁）：
如果没有则使用CAS操作竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。


### 关闭偏向锁

```text
偏向锁在Java运行环境中默认开启，但是不会随着程序启动立即生效，而是在启动几秒种后才激活，可以使用参数关闭延迟：
-XX：BiasedLockingStartupDelay=0 
同样可以关闭偏向锁
 -XX：UseBiasedLocking=false,那么程序默认进入轻量级锁。
```

### 轻量级锁

>轻量级锁是JDK1.6之中加入的新型锁机制，它并不是来代替重量级锁的，他的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

### 轻量级锁加锁

>线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于储存锁记录的空间（LockRecord），并将对象头的Mark Word信息复制到锁记录中。然后线程尝试使用CAS将对象头的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，并且对象的锁标志位转变为“00”，如果失败，表示其他线程竞争锁，当前线程便会尝试自旋获取锁。如果有两条以上的线程竞争同一个锁，那么轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态变为“10”，MarkWord中储存的就是指向重量级锁（互斥量）的指针，后面等待的线程也要进入阻塞状态。


### 轻量级锁解锁
>轻量级锁解锁时，同样通过CAS操作将对象头换回来。如果成功，则表示没有竞争发生。如果失败，说明有其他线程尝试过获取该锁，锁同样会膨胀为重量级锁。在释放锁的同时，唤醒被挂起的线程。


